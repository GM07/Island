#include "../headers.h"
#include "DemonSpawner.h"

/**
 * @brief Constructor
 * @param   position        Position to follow (of the player)
 * @param   spawningRadius  Radius in which the entities will spawn
 * @param   demon           Demon template for spawning
 * @param   maxEntities     Maximum of entities that can be spawned 
 */
DemonSpawner::DemonSpawner(const Vector& position, const float spawningRadius, const Demon& demon, const int maxEntities)
    :   spawningRadius_(spawningRadius)
    ,   position_(position)
    ,   m_Demon(demon)
    ,   maxEntities_(maxEntities)
{
    spawningClock_.restart();

    if (maxEntities_ > 0)
        entities_.reserve(maxEntities_ * sizeof(Demon));
}

/**
 * @brief Destructor
 */
DemonSpawner::~DemonSpawner()
{

}

/**
 * @brief Function that updates the spawner
 * @param dt                Time since last frame
 */
void DemonSpawner::update(const float& dt)
{
    if (spawningClock_.getElapsedTime().asSeconds() >= 1)
    {
        spawningClock_.restart();
        if (maxEntities_ > 0 && entities_.size() < maxEntities_ ||
            maxEntities_ <= 0)
            spawn();
    }

    for (auto& entity : entities_)
    {
        entity->update(dt);
    }

    
}


/**
 * @brief Function that renders the entities generated by the spawner
 * @param target            Where to draw the entities
 */
void DemonSpawner::render(std::shared_ptr<sf::RenderTarget> target)
{
    for (const auto& entity : entities_)
    {
        entity->render(target);
    }
}

/**
 * @brief Function that adds a texture to the entities
 * @param texture       Texture to add
 */
void DemonSpawner::addTexture(std::shared_ptr<sf::Texture>& texture)
{
    texture_ = texture;
    m_Demon.addTexture(texture);
}

/**
 * @brief Function that collides the player with the demons
 * @param player        Player
 */
void DemonSpawner::collide(Player& player) 
{

    for (auto it = entities_.begin(); it != entities_.end(); ++it)
    {
        auto& entity = *it;
        EntityCollider::handleCollisionPE(&player, entity.get());

        if (entity->getLife() <= 0)
            entities_.erase(it);
    }
}

/**
 * @brief Function that spawns an entity
 */
void DemonSpawner::spawn()
{
    // Find a position in the radius
    srand(time(0));
    float angle = rand() % 360;
    Vector pos(static_cast<float>(cos(angle)) * spawningRadius_, static_cast<float>(sin(angle)) * spawningRadius_);

    entities_.push_back(std::make_unique<Demon>(m_Demon));
    
    if (texture_ != nullptr)
        entities_[entities_.size() - 1]->addTexture(texture_);
    
    entities_[entities_.size() - 1]->setPosition(pos + position_);
}






